name: Deploy Backend to EC2

on:
  push:
    branches:
      - main
      - develop
  workflow_dispatch:

env:
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
  BACKEND_APP_DIR: ${{ vars.BACKEND_APP_DIR || '/opt/ecommerce' }}
  BACKEND_PORT: ${{ vars.BACKEND_PORT || '8081' }}
  EC2_SSH_USER: ${{ vars.EC2_SSH_USER || 'ubuntu' }}
  EC2_HOST: ${{ secrets.EC2_HOST || vars.EC2_HOST || '100.53.155.105' }}
  EC2_INSTANCE_ID: ${{ vars.EC2_INSTANCE_ID || 'i-0348f34ea246a89e0' }}

jobs:
  deploy-backend:
    name: Build and Deploy Backend
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Java 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven

      - name: Build JAR
        run: mvn clean package -DskipTests

      - name: Resolve artifact
        id: artifact
        shell: bash
        run: |
          JAR_PATH=$(ls target/*.jar | head -n 1)
          if [ -z "$JAR_PATH" ]; then
            echo "No se encontró JAR en target/"
            exit 1
          fi
          echo "jar_path=$JAR_PATH" >> "$GITHUB_OUTPUT"

      - name: Configure AWS credentials (optional for host resolution)
        if: env.EC2_HOST == '' && env.EC2_INSTANCE_ID != ''
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Resolve EC2 host
        id: ec2
        shell: bash
        run: |
          TARGET_HOST="${{ env.EC2_HOST }}"

          if [ -z "$TARGET_HOST" ] && [ -n "${{ env.EC2_INSTANCE_ID }}" ]; then
            TARGET_HOST=$(aws ec2 describe-instances \
              --instance-ids "${{ env.EC2_INSTANCE_ID }}" \
              --region "${{ env.AWS_REGION }}" \
              --query 'Reservations[0].Instances[0].PublicIpAddress' \
              --output text)
          fi

          if [ -z "$TARGET_HOST" ] || [ "$TARGET_HOST" = "None" ]; then
            echo "No se pudo resolver EC2 host. Configura secrets.EC2_HOST o vars.EC2_HOST o vars.EC2_INSTANCE_ID"
            exit 1
          fi

          echo "host=$TARGET_HOST" >> "$GITHUB_OUTPUT"

      - name: Prepare SSH
        shell: bash
        run: |
          if [ -z "${{ secrets.EC2_SSH_KEY }}" ]; then
            echo "Falta secret EC2_SSH_KEY"
            exit 1
          fi
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H "${{ steps.ec2.outputs.host }}" >> ~/.ssh/known_hosts

      - name: Prepare deployment directory
        shell: bash
        run: |
          ssh -o StrictHostKeyChecking=no "${{ env.EC2_SSH_USER }}@${{ steps.ec2.outputs.host }}" << EOF
            sudo mkdir -p "${{ env.BACKEND_APP_DIR }}"
            sudo chown -R ubuntu:ubuntu "${{ env.BACKEND_APP_DIR }}"
          EOF

      - name: Upload JAR
        shell: bash
        run: |
          scp -o StrictHostKeyChecking=no \
            "${{ steps.artifact.outputs.jar_path }}" \
            "${{ env.EC2_SSH_USER }}@${{ steps.ec2.outputs.host }}:${{ env.BACKEND_APP_DIR }}/app.jar"

      - name: Restart service
        shell: bash
        run: |
          ssh -o StrictHostKeyChecking=no "${{ env.EC2_SSH_USER }}@${{ steps.ec2.outputs.host }}" << 'EOF'
            cd "${{ env.BACKEND_APP_DIR }}"
            pkill -f "app.jar" || true
            sleep 2
            nohup java -jar app.jar > backend.log 2>&1 &
            JAVA_PID=$!
            echo "Backend iniciado con PID: $JAVA_PID"
            
            # Esperar a que Spring Boot arranque
            echo "Esperando 55 segundos a que Spring Boot arranque completamente..."
            sleep 55
            
            # Verificar que el proceso siga corriendo
            if ! kill -0 $JAVA_PID 2>/dev/null; then
              echo "❌ El proceso Java murió. Últimas líneas del log:"
              tail -30 backend.log
              exit 1
            fi
            
            # Healthcheck con reintentos
            for i in 1 2 3 4 5; do
              echo "Intento $i de 5 - Probando conexión HTTP..."
              
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 --max-time 10 "http://127.0.0.1:${{ env.BACKEND_PORT }}/api/users" 2>/dev/null || echo "000")
              
              echo "Código HTTP: $HTTP_CODE"
              
              # Cualquier respuesta que no sea 000 (error de conexión) o 5xx es éxito
              if [ "$HTTP_CODE" != "000" ] && [ "$HTTP_CODE" -lt 500 ]; then
                echo "✓ Backend respondiendo correctamente (HTTP $HTTP_CODE)"
                exit 0
              fi
              
              if [ $i -lt 5 ]; then
                echo "Esperando 5 segundos antes del siguiente intento..."
                sleep 5
              fi
            done
            
            # Si llegamos aquí, el healthcheck falló
            echo ""
            echo "❌ Backend no pasó el healthcheck después de 5 intentos"
            echo ""
            echo "Log completo:"
            cat backend.log
            exit 1
          EOF

      - name: Result
        run: echo "Backend desplegado en http://${{ steps.ec2.outputs.host }}:${{ env.BACKEND_PORT }}"
